" Link to the reference implementation:
" https://github.com/rescript-lang/rescript-vscode/blob/0dbf2eb9cdb0bd6d95be1aee88b73830feecb5cc/server/src/utils.ts#L129-L329


" Parses all syntax errors from the output of the ReScript compiler /
" compiler.log
"
" {output} is a list of lines (usually generated by systemlist)
" Every parsed filepath will be replaced with {filename} (useful for replacing
" temporary filenames)
"
" It returns a list of dicts containing the error information. Those dicts
" follow the same format as documented in |setqflist()|
function! rescript#parsing#ParseCompilerErrorOutput(lines)
  let ret = []

  let l:i = 0

  " warning_number > -1 means it is a warning
  let item = {
        \'filedata': [],
        \'warning_number': -1,
        \'preview': [],
        \'text': ""}

  " used for file preview: 2 spaces = start of error message
  let spaces = 0

  " header, filedata, file_preview , error_msg
  let mode = "header"

  let l:last = len(a:lines) - 1

  while l:i < len(a:lines)
    let line = a:lines[l:i]

    if mode ==? "header"
      let trimmed = trim(line)

      if trimmed ==# "We've found a bug for you!"
        let mode = "filedata"
        let item = {
              \'filedata': [],
              \'warning_number': -1,
              \'preview': [],
              \'text': ""}
      elseif trimmed ==# "Syntax error!"
        let mode = "filedata"
        let item = {
              \'filedata': [],
              \'warning_number': -1,
              \'preview': [],
              \'text': "(Syntax)"}
      else
        let l:tokens = matchlist(line, 'Warning number \([0-9]\+\).*')

        if !empty(l:tokens)
          let mode = "filedata"
          let item = {
                \'filedata': [],
                \'warning_number': l:tokens[1],
                \'preview': [],
                \'text': ""}
        endif
      endif
    elseif mode ==? "filedata"
      let l:tokens = matchlist(line, '\s*\(.*\.res\)\s*:*\([0-9]\+\):\([0-9]\+\).*')
      if !empty(l:tokens)
        let item.filedata = l:tokens
        let mode = "file_preview"
      endif 
    elseif mode ==? "file_preview"
      if trim(line) == ""
        let spaces += 1
      else
        let item.preview = add(item.preview, line)
      endif
      if spaces == 2
        let mode = "error_msg"
        let spaces = 0
      endif
    elseif mode ==? "error_msg"
      let trimmed = trim(get(a:lines, l:i+1, ""))

      if l:i == l:last 
            \ || trimmed ==# "We've found a bug for you!"
            \ || trimmed ==# "Syntax error!"
            \ || matchstr(trimmed, 'Warning number [0-9]\+') != ""
        if !empty(item.filedata)
          let l:type = item.warning_number > -1 ? "W" : "E"
          let text = item.warning_number > -1 ? 
                \"(Warning " . item.warning_number . ") " . item.text
                \: item.text
          call add(ret, {"filename": item.filedata[1],
                \"bufnr": item.filedata[1],
                \"lnum": item.filedata[2],
                \"col": item.filedata[3],
                \"type": l:type,
                \"text": text})
          let l:filedata = []
        endif
        let mode = "header"
      else
        let str = substitute(line, '^\s*\(.\{-}\)\s*$', '\1', '')
        let text = item.text
        if str != ""
          let text = text == "" ? str : text . " " . str
        endif
        let item.text = text
      endif

    endif
    let l:i += 1
  endwhile

  return ret
endfunction

" Parses {lines} of strings read from a .compiler.log file and returns a list
" of parsed lines (list of lists of strings) that were enclosed by START /
" DONE markers
function! rescript#parsing#ParseCompilerLogEntries(lines)
  let ret = []

  " start, collect
  let mode = "start"

  let i = 0

  let content = []

  while i < len(a:lines)
    let line = a:lines[i] 

    if mode ==? "start"
      if matchstr(line, '#Start') != ""
        let mode = "collect"
        let content = []
      endif
    elseif mode ==? "collect"
      if matchstr(line, '#Done') != ""
        let mode = "start"
        if !empty(content)
          let ret = add(ret, content)
        endif
      else
        let content = add(content, line)
      endif
    endif
    let i = i + 1
  endwhile

  return ret
endfunction
